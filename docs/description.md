# Описание процессора

Архитектура процессора - Фон Неймановская, 16 разрядная, предназначение всех регистов строго определено, данные должны храниться в памяти.

Процессор будет собран из отдельных модулей, которые будут состоять из макетной платы с DIP микросхемами логики серии 74HC и микросхем памяти с параллельным вводом/выводом.

Все линии данных и управляющих сигналов будут подключены к светодиодам для обозначения их текущего значения. Светодиоды будут запитаны от отдельной линии питания, чтобы они не влияли на работу процессора, и их можно было выключить.

Записывать и читать значения в оперативной памяти можно будет вручную с помощью переключателей и кнопок для программирования и отладки. Также с помощью кнопок можно будет выполнять инструкции по тактам, нажимаешь кнопку - выполняется 1 такт.

# Модули процессора

## MEM_ADDR_REG (регистр адреса памяти)

#### управляющие сигналы
- in mem_addr_write - если 1, ввод адреса с system_bus при переходе clk 0->1

#### базовые сигналы
- in clk
- in x16 system_bus

#### связь с MEM
- out x16 mem_addr - постоянный вывод значения регистра адреса

## MEM (контроллер памяти)

#### управляющие сигналы

- in mem_read - если 1, вывод данных в system_bus
- in mem_write - если 1, ввод данных с system_bus при переходе clk 0->1
- in 8_bit - выбор размера данных (0 - 16 бит, 1 - 8 бит)

#### базовые сигналы
- in clk
- in/out x16 system_bus

#### связь с MEM_ADDR_REG
- in x16 mem_addr - адрес ячейки памяти

## IO_ADDR_REG (регистр адреса порта ввода-вывода)

#### управляющие сигналы
- in io_addr_write - если 1, ввод адреса с system_bus при переходе clk 0->1

#### базовые сигналы
- in clk
- in x8 system_bus

#### связь с IO_PORT
- out x8 io_addr - постоянный вывод первых 8 бит значения регистра адреса

## IO_PORT (порт ввода-вывода)

#### управляющие сигналы
- in io_read - если 1, вывод данных в system_bus
- in io_write - если 1, ввод данных с system_bus при переходе clk 0->1
- in 8_bit - выбор размера данных (0 - 16 бит, 1 - 8 бит)

#### базовые сигналы
- in clk
- in/out x16 system_bus

#### связь с IO_ADDR_REG
- in x8 io_addr - работа описана выше

## ACC_REG (регистр аккумулятор)

#### управляющие сигналы
- in reg_read - если 1, вывод данных в system_bus
- in reg_write - если 1 и reg_shl=reg_shr=1, ввод данных с alu_result при переходе clk 0->1,
                         если 0 и reg_shl=reg_shr=1, ввод данных с system_bus при переходе clk 0->1,
- in reg_shr - если 1 и reg_shl=0, выолнить сдвиг вправо
- in reg_shl - если 1 и reg_shr=0, выолнить сдвиг влево

#### базовые сигналы
- in clk
- in/out x16 system_bus

#### связь с АЛУ
- in x16 alu_result - работа описана выше
- out x16 reg_value - постоянный вывод данных

## FLAGS_REG (регистр флагов)

#### управляющие сигналы
- in flags_store - если 1, ввод значений с alu_x при переходе clk 0->1 

#### базовые сигналы
- in clk

#### связь с АЛУ и УУ
- in alu_zf - работа описана выше
- in alu_sf - работа описана выше
- in alu_cf - работа описана выше
- out flags_zf - постоянный вывод zf
- out flags_sf - постоянный вывод sf
- out flags_cf - постоянный вывод cf

## ALU (арифметическо-логическое устройство)

#### управляющие сигналы
- in alu_carry - бит переноса
- in alu_mode  - режим АЛУ (0 - алгебра, 1 - логика)
- in x4 alu_op - выбор операции

#### базовые сигналы
- in x16 system_bus

#### связь с ACC_REG
- in x16 reg_value - работа описана выше
- out x16 alu_result - работа описана выше

#### связь с FLAGS_REG
- out alu_zf - 1, если результат=0
- out alu_sf - 1, если результат<0 (>32767)
- out alu_cf - 1, если результат не влез в reg_value

## INST_ADDR_REG (регистр адреса инструкции)

#### управляющие сигналы
- in ip_inc - если 1, инкрементировать значение при переходе clk 0->1 
- in ip_write - если 1, записать значение из system_bus при переходе clk 0->1
- in ip_read - если 1, выводить значение в system_bus

#### базовые сигналы
- in clk
- in/out x16 system_bus

## INST_REG (регистр инструкции)

#### управляющие сигналы
- in ir_read - ввод первых 8 бит значения с system_bus при переходе clk 0->1

#### базовые сигналы
- in clk
- in x16 system_bus

#### связь с MICROCODE_ROM
- out x8 ir_value - постоянный вывод значения

## COUNT (счётчик микрооперации)

#### управляющие сигналы
- in count_reset - если 1, сброс значения в 0, при переходе clk 0->1

#### базовые сигналы
- in clk - инкрементировать значение при при переходе clk 0->1, если count_reset=0

#### связь с MICROCODE_ROM
- out x4 count_value - постоянный вывод значения

## MICROCODE_ROM (память микрокода / комбинационная схема управления)

#### связь с INST_REG 
- in x8 ir_value - биты 0-8 адреса в ROM

#### связь с COUNT
- in x4 count_value - биты 9-11 адреса в ROM

#### связь с FLAGS_REG
- in flags_zf - бит 12 адреса в ROM
- in flags_sf - бит 13 адреса в ROM
- in flags_cf - бит 14 адреса в ROM

#### базовые сигналы
- in rst - сброс
- in clk - вывод управляющих сигналов при переходе clk 1->0

#### управляющие сигналы
- out !MEM_BASE_WE
- out !MEM_OFFSET_WE
- out !MEM_OFFSET_CLR
- out !MEM_WE
- out !MEM_OE
  
- out  ALU_CIN
- out  ALU_MODE
- out  ALU_OP0
- out  ALU_OP1
- out  ALU_OP2
- out  ALU_OP3
  
- out  FLAGS_WE
- out !FLAGS_OE
- out  FLAGS_ALU

- out !ACC_OE 
- out  ACC_SHR
- out  ACC_SHL
- out  ACC_ALU

- out !B_WE
- out !B_OE
- out !C_WE
- out !C_OE
- out !D_WE
- out !D_OE
- out !E_WE
- out !E_OE
- out !F_WE
- out !F_OE
- out !G_WE
- out !G_OE
- out !H_WE
- out !H_OE
  
- out !BP_WE
- out !BP_OE

- out !SP_WE
- out !SP_OE
- out !SP_CNT
- out  SP_DOWN

- out !IP_WE
- out !IP_OE
- out  IP_INC
  
- out !IR_WE
- out !IR_BYTE_OE
  
- out CNT_CLR
  
- out CLK_STOP

## CLOCK (генератор тактового сигнала)

#### управляющие сигналы
- in clock_stop - если 1, выключить генерацию такового сигнала
- in clock_start (только ручная кнопка) - если 1, включить генерацию тактового сигнала
- in clock_step (только ручная кнопка) - если 1, и генерация такового сигнала выключена, выводить clk=1, иначе если генерация такового сигнала выключена выводить clk=0

#### базовые сигналы
- out clk
